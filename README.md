# SWE_Practical_Works

## Practical 2
Exercises for Students
1. Modify the program to count the number of unique words in the text.
2. Add a function to find the longest word in the text.
3. Implement a feature to count the occurrences of a specific word (case-insensitive).
4. Create a function to calculate the percentage of words that are longer than the average word length.

## Practical 3
Exercises for Students
1. Modify the iterative function to return a list of Fibonacci numbers up to n, instead of just the nth number.
2. Implement a function that finds the index of the first Fibonacci number that exceeds a given value.
3. Create a function that determines if a given number is a Fibonacci number.
4. Implement a function that calculates the ratio between consecutive Fibonacci numbers and observe how it approaches the golden ratio.

## Practical 4
Exercises for Students
1. Modify the linear search function to return all indices where the target appears, not just the first one.
2. Implement a function that uses binary search to find the insertion point for a target value in a sorted list.
3. Create a function that counts the number of comparisons made in each search algorithm.
4. Implement a jump search algorithm and compare its performance with linear and binary search.

## Practical 5
Exercises for Students
1. Implement a function that uses a stack to evaluate postfix expressions.
2. Create a function that uses two stacks to implement a queue.
3. Use a queue to implement a basic task scheduler that processes tasks in the order they were added.
4. Implement a function that uses a stack to convert infix expressions to postfix.

## Practical 6
1. Exercises for Students
2. Implement a method to find the middle element of the linked list.
3. Create a method to detect if the linked list has a cycle.
4. Implement a method to remove duplicates from an unsorted linked list.
5. Add a method to merge two sorted linked lists into a single sorted linked list.

## Practical 7
Exercises for Students
1. Implement a method to find the maximum value in the BST.
2. Add a method to count the total number of nodes in the BST.
3. Implement a level-order traversal (breadth-first search) for the BST.
4. Create a method to find the height of the BST.
5. Implement a method to check if the tree is a valid BST.

## Practical 8
Exercises for Students
1. Implement an in-place version of Quick Sort to improve its space efficiency.
2. Modify Bubble Sort to stop early if the list becomes sorted before all passes are complete.
3. Implement a hybrid sorting algorithm that uses Insertion Sort for small subarrays in Merge Sort or Quick Sort.
4. Create a visualization of how each sorting algorithm works using a library like Matplotlib.

## Practical 9
Exercises for Students
1. Implement a method to find the shortest path between two vertices using BFS.
2. Add a method to detect cycles in the graph.
3. Implement Dijkstra's algorithm to find the shortest path in a weighted graph.
4. Create a method to determine if the graph is bipartite.